# 分布式事务TCC实现原理
#### 一、业务场景介绍
假设有一个电商系统，里面有一个支付订单的场景。

订单支付后，我们需要做下面的步骤：

* 更改订单的状态为“已支付” 

* 扣减商品库存

* 给会员增减积分

* 创建销售出货单通知仓库发货
![image](https://github.com/bertcodes/ability/blob/master/distributedtransaction/tcc/tcc-1td.png)
#### 二、不用分布式事务思考
上述几个步骤，要么一起成功，要么一起失败，必须是一个整体的事务，扣减库存如果失败了不回滚其他服务会导致事务

一致性问题，比如扣减库存失败了需回滚与取消其他服务：
![image](https://github.com/bertcodes/ability/blob/master/distributedtransaction/tcc/tcc-2td.png)

#### 三、落地TCC分布式事务
##### 3.1、TCC实现阶段一：Try
首先，订单服务那儿，他的代码大致来说应该是这样子的：
![image](https://github.com/bertcodes/ability/blob/master/distributedtransaction/tcc/tcc-3td.png)

其实就是订单服务完成本地数据库操作之后，通过Spring Cloud的Feign来调用其他的各个服务罢了。

我们对这个订单服务修改点儿代码好不好。

首先，上面那个订单服务先把自己的状态修改为：OrderStatus.UPDATING。

这是啥意思呢？也就是说，在pay()那个方法里，你别直接把订单状态修改为已支付啊！你先把订单状态修改为UPDATING，也就是修改中的意思。

这个状态是个没有任何含义的这么一个状态，代表有人正在修改这个状态罢了。

然后呢，库存服务直接提供的那个reduceStock()接口里，也别直接扣减库存啊，你可以是冻结掉库存。

举个例子，本来你的库存数量是100，你别直接100 - 2 = 98，扣减这个库存！

你可以把可销售的库存：100 - 2 = 98，设置为98没问题，然后在一个单独的冻结库存的字段里，设置一个2。也就是说，有2个库存是给冻结了。

积分服务的addCredit()接口也是同理，别直接给用户增加会员积分。你可以先在积分表里的一个预增加积分字段加入积分。

比如：用户积分原本是1190，现在要增加10个积分，别直接1190 + 10 = 1200个积分啊！

你可以保持积分为1190不变，在一个预增加字段里，比如说prepare_add_credit字段，设置一个10，表示有10个积分准备增加。

仓储服务的saleDelivery()接口也是同理啊，你可以先创建一个销售出库单，但是这个销售出库单的状态是“UNKNOWN”。

也就是说，刚刚创建这个销售出库单，此时还不确定他的状态是什么呢！

上面这套改造接口的过程，其实就是所谓的TCC分布式事务中的第一个T字母代表的阶段，也就是Try阶段。

总结上述过程，如果你要实现一个TCC分布式事务，首先你的业务的主流程以及各个接口提供的业务含义，不是说直接完成那个业务操作，而是完成一个Try的操作。

这个操作，一般都是锁定某个资源，设置一个预备类的状态，冻结部分数据，等等，大概都是这类操作。

咱们来一起看看下面这张图，结合上面的文字，再来捋一捋这整个过程。
![image](https://github.com/bertcodes/ability/blob/master/distributedtransaction/tcc/tcc-4td.png)

##### 3.2、TCC实现阶段二：Confirm
然后就分成两种情况了，第一种情况是比较理想的，那就是各个服务执行自己的那个Try操作，都执行成功了，bingo！

这个时候，就需要依靠TCC分布式事务框架来推动后续的执行了。

这里简单提一句，如果你要玩儿TCC分布式事务，必须引入一款TCC分布式事务框架，比如国内开源的ByteTCC、himly、tcc-transaction。

否则的话，感知各个阶段的执行情况以及推进执行下一个阶段的这些事情，不太可能自己手写实现，太复杂了。

如果你在各个服务里引入了一个TCC分布式事务的框架，订单服务里内嵌的那个TCC分布式事务框架可以感知到，各个服务的Try操作都成功了。

此时，TCC分布式事务框架会控制进入TCC下一个阶段，第一个C阶段，也就是Confirm阶段。

为了实现这个阶段，你需要在各个服务里再加入一些代码。

比如说，订单服务里，你可以加入一个Confirm的逻辑，就是正式把订单的状态设置为“已支付”了，大概是类似下面这样子：



库存服务也是类似的，你可以有一个InventoryServiceConfirm类，里面提供一个reduceStock()接口的Confirm逻辑，这里就是将之前冻结库存字段的2个库存扣掉变为0。

这样的话，可销售库存之前就已经变为98了，现在冻结的2个库存也没了，那就正式完成了库存的扣减。

积分服务也是类似的，可以在积分服务里提供一个CreditServiceConfirm类，里面有一个addCredit()接口的Confirm逻辑，就是将预增加字段的10个积分扣掉，然后加入实际的会员积分字段中，从1190变为1120。

仓储服务也是类似，可以在仓储服务中提供一个WmsServiceConfirm类，提供一个saleDelivery()接口的Confirm逻辑，将销售出库单的状态正式修改为“已创建”，可以供仓储管理人员查看和使用，而不是停留在之前的中间状态“UNKNOWN”了。

好了，上面各种服务的Confirm的逻辑都实现好了，一旦订单服务里面的TCC分布式事务框架感知到各个服务的Try阶段都成功了以后，就会执行各个服务的Confirm逻辑。

订单服务内的TCC事务框架会负责跟其他各个服务内的TCC事务框架进行通信，依次调用各个服务的Confirm逻辑。然后，正式完成各个服务的所有业务逻辑的执行。

同样，给大家来一张图，顺着图一起来看看整个过程。
![image](https://github.com/bertcodes/ability/blob/master/distributedtransaction/tcc/tcc-5td.png)

##### 3.3、TCC实现阶段三：Cancel
好，这是比较正常的一种情况，那如果是异常的一种情况呢？

举个例子：在Try阶段，比如积分服务吧，他执行出错了，此时会怎么样？

那订单服务内的TCC事务框架是可以感知到的，然后他会决定对整个TCC分布式事务进行回滚。

也就是说，会执行各个服务的第二个C阶段，Cancel阶段。

同样，为了实现这个Cancel阶段，各个服务还得加一些代码。

首先订单服务，他得提供一个OrderServiceCancel的类，在里面有一个pay()接口的Cancel逻辑，就是可以将订单的状态设置为“CANCELED”，也就是这个订单的状态是已取消。

库存服务也是同理，可以提供reduceStock()的Cancel逻辑，就是将冻结库存扣减掉2，加回到可销售库存里去，98 + 2 = 100。

积分服务也需要提供addCredit()接口的Cancel逻辑，将预增加积分字段的10个积分扣减掉。

仓储服务也需要提供一个saleDelivery()接口的Cancel逻辑，将销售出库单的状态修改为“CANCELED”设置为已取消。

然后这个时候，订单服务的TCC分布式事务框架只要感知到了任何一个服务的Try逻辑失败了，就会跟各个服务内的TCC分布式事务框架进行通信，然后调用各个服务的Cancel逻辑。

大家看看下面的图，直观的感受一下。
![image](https://github.com/bertcodes/ability/blob/master/distributedtransaction/tcc/tcc-6td.png)







