# 分布式事务TCC实现原理
#### 一、业务场景介绍
假设有一个电商系统，里面有一个支付订单的场景。

订单支付后，我们需要做下面的步骤：

* 更改订单的状态为“已支付” 

* 扣减商品库存

* 给会员增减积分

* 创建销售出货单通知仓库发货
![image](https://github.com/bertcodes/ability/blob/master/distributedtransaction/tcc/tcc-1td.png)
#### 二、不用分布式事务思考
上述几个步骤，要么一起成功，要么一起失败，必须是一个整体的事务，扣减库存如果失败了不回滚其他服务会导致事务

一致性问题，比如扣减库存失败了需回滚与取消其他服务：
![image](https://github.com/bertcodes/ability/blob/master/distributedtransaction/tcc/tcc-2td.png)

#### 三、落地TCC分布式事务
##### 3.1、TCC实现阶段一：Try
首先，订单服务那儿，他的代码大致来说应该是这样子的：
![image](https://github.com/bertcodes/ability/blob/master/distributedtransaction/tcc/tcc-3td.png)

其实就是订单服务完成本地数据库操作之后，通过Spring Cloud的Feign来调用其他的各个服务罢了。

我们对这个订单服务修改点儿代码好不好。

首先，上面那个订单服务先把自己的状态修改为：OrderStatus.UPDATING。

这是啥意思呢？也就是说，在pay()那个方法里，你别直接把订单状态修改为已支付啊！你先把订单状态修改为UPDATING，也就是修改中的意思。

这个状态是个没有任何含义的这么一个状态，代表有人正在修改这个状态罢了。

然后呢，库存服务直接提供的那个reduceStock()接口里，也别直接扣减库存啊，你可以是冻结掉库存。

举个例子，本来你的库存数量是100，你别直接100 - 2 = 98，扣减这个库存！

你可以把可销售的库存：100 - 2 = 98，设置为98没问题，然后在一个单独的冻结库存的字段里，设置一个2。也就是说，有2个库存是给冻结了。

积分服务的addCredit()接口也是同理，别直接给用户增加会员积分。你可以先在积分表里的一个预增加积分字段加入积分。

比如：用户积分原本是1190，现在要增加10个积分，别直接1190 + 10 = 1200个积分啊！

你可以保持积分为1190不变，在一个预增加字段里，比如说prepare_add_credit字段，设置一个10，表示有10个积分准备增加。

仓储服务的saleDelivery()接口也是同理啊，你可以先创建一个销售出库单，但是这个销售出库单的状态是“UNKNOWN”。

也就是说，刚刚创建这个销售出库单，此时还不确定他的状态是什么呢！

上面这套改造接口的过程，其实就是所谓的TCC分布式事务中的第一个T字母代表的阶段，也就是Try阶段。

总结上述过程，如果你要实现一个TCC分布式事务，首先你的业务的主流程以及各个接口提供的业务含义，不是说直接完成那个业务操作，而是完成一个Try的操作。

这个操作，一般都是锁定某个资源，设置一个预备类的状态，冻结部分数据，等等，大概都是这类操作。

咱们来一起看看下面这张图，结合上面的文字，再来捋一捋这整个过程。
![image](https://github.com/bertcodes/ability/blob/master/distributedtransaction/tcc/tcc-4td.png)




